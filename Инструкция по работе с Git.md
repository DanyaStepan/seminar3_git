# Инструкция по работе с Git.

## Что такое Git?

_**Git**_ — это распределенная система контроля версий нашего кода. Зачем она нам? Для распределенных команд нужна какая-то система управления работы. Нужна, чтобы отслеживать изменения, которые происходят со временем. 

То есть шаг за шагом мы видим, какие файлы изменились и как. Особенно это важно, когда анализируешь, что было проделано в рамках одной задачи: это дает возможность возвращаться назад.


## Настройка Git.

У гита есть настройка пользователя, от которого будет идти работа. Это разумная и необходимая вещь, так как когда создается коммит, гит берет именно эту информацию для поля Author.

Чтобы настроить имя пользователя и пароль для всех проектов, нужно прописать следующие команды:

* git config --global user.name ”Ivan Ivanov”
* git config --global user.email ivan.ivanov@gmail.com

Если есть необходимость для конкретного проекта поменять автора (для личного проекта, например), можно убрать --global, и так получится:
 
X* git config user.name ”Ivan Ivanov”
* git config user.email ivan.ivanov@gmail.com

## Что говорит Git? 

*Какие слова и действия?*

* гит репозиторий (git repository);
* коммит (commit);
* ветка (branch);
* смерджить (merge);
* конфликты (conflicts);
* спулить (pull);
* запушить (push);
* как игнорировать какие-то файлы (.gitignore).

И так далее.

*У Гита есть несколько состояний, которые нужно понять и запомнить:*

1. неотслеживаемое (untracked);
2. измененное (modified);
3. подготовленное (staged);
4. закомиченное (committed).

*Как их понимать?*

**1.** Это состояния, в которых находятся файлы из нашего кода. То есть, их жизненный путь обычно выглядит так:
Файл, который создан и не добавлен в репозиторий, будет в состоянии untracked.

**2.** Делаем изменения в файлах, которые уже добавлены в гит репозиторий — находятся в состоянии modified.

**3.** Из тех файлов, которые мы изменили, выбираем только те (или все), которые нужны нам (например, скомпилированные классы нам не нужны), и эти классы с изменениями попадают в состояние staged.

**4.** Из заготовленных файлов из состояния staged создается коммит и переходит уже в гит репозиторий. После этого staged состояние — пустое. А вот modified еще может что-то содержать.

## Основные команды.

Основные команды Git. 

__*git init*__ — инициализирует новый репозиторий GIT и начинает отслеживание существующего каталога. В существующий каталог добавляется скрытая вложенная папка, в которой размещается внутренняя структура данных, необходимая для управления версиями.

__*git clone*__ — создает локальную копию проекта, который уже существует удаленно. Клон включает в себя все файлы проекта, журнал и ветви.

__*git add*__ — подготавливает изменение. GIT отслеживает изменения в базе кода разработчика, но для включения изменений в журнал проекта необходимо подготавливать их и создавать моментальные снимки. Эта команда выполняет первую часть этого двухэтапного процесса, то есть подготовку. Все подготовленные изменения станут частью следующего моментального снимка и журнала проекта. Раздельные подготовка и фиксация дают разработчикам полный контроль над историей проекта без необходимости изменять подход к написанию кода и работе в целом.

__*git commit*__ — сохраняет моментальный снимок в журнале проекта и завершает процесс отслеживания изменений. Иначе говоря, фиксация похожа на создание фотографии. Все, что было подготовлено с помощью команды git add, станет частью моментального снимка при использовании git commit.

__*git status*__ — выводит состояние изменений: не отслеживаются, изменены или подготовлены.

__*git branch*__ — показывает ветви, с которыми ведется локальная работа.

__*git merge*__ — выполняет слияние линий разработки. Эта команда обычно применяется для объединения изменений, внесенных в двух разных ветвях. Например, разработчик выполняет слияние, когда необходимо объединить изменения из ветви функции с главной ветвью для развертывания.

__*git pull*__ — применяет к локальной линии разработки обновления из удаленного аналога. Разработчики используют эту команду, если коллега выполнил фиксации в ветви удаленного репозитория и эти изменения нужно отразить в локальной среде.

__*git push*__ — обновляет удаленный репозиторий с учетом фиксаций, выполненных в ветви локально.

## Начало работы с Git.

Можно работать и только с локальный репозиторием, и с удаленным.

Для отработки нужных команд можно воспользоваться только локальным репозиторием. Он хранит всю информацию только локально в проекте в папке .git.

Если говорить об удаленном, то вся информация хранится где-то на удаленном сервере: локально хранится только копия проекта, изменения которой можно запушить (git push) в удаленный репозиторий.

Чтобы создать локальный репозиторий, нужно написать:
1. git init

После этого будет создана папка .git в том месте, где находится консоль.

*.git* — это папка, которая хранит всю информацию о гит репозитории. Ее удалять не нужно 

Далее, добавляются файлы в этот проект, и их состояние становится Untracked. Чтобы посмотреть, какой статус работы на данный момент, пишем:

2. git status 

Мы находимся в master ветке, и пока мы не перейдем в другую, 
так все и останется.

Таким образом видно, какие файлы изменены, но еще не добавлены в состояние staged. Чтобы добавить их в состояние staged, нужно написать git add. Здесь может быть несколько вариантов, например:
* git add -A — добавить все файлы из состояния в staged;
* git add . — добавить все файлы из этой папки и все внутренних. По сути тоже самое, что и предыдущее;
* git add <имя файла> — добавляет только конкретный файл. Здесь можно пользоваться регулярными выражениями, чтобы добавлять по какому-то шаблону. Например, git add *.java: это значит, что нужно добавить только файлы с расширением java.

Далее пишем:
3. git add *.txt

Далее так же через команду git status проверяем отслеживание.

Теперь можем создать комит:
4. git commit -m "коментарий"

Далее есть отличная команда, чтобы посмотреть на историю коммитов в ветке - *git log*



## Что такое commit?

__*Коммит*__ — это основной объект в управлении контроля версий. Он содержит все изменения за время этого коммита. Коммиты связаны между с собой как односвязный список. 

А именно: 

Есть первый коммит. Когда создается второй коммит, то он (второй) знает, что идет после первого. И таким образом можно отследить информацию. 

Также у коммита есть еще своя информация, так называемые метаданные:
* уникальный идентификатор коммита, по которому можно его найти;
имя автора коммита, который создал его;
дата создания коммита;
комментарий, который описывает, что было сделано во время этого коммита.
Вот как это выглядит:

![commit](commit.jpg)

Для того, чтобы создать commit, нам необходимо указать к нему комментарий. Для этого используется "флажок" -m. Выглядит это так: __git commit -m__ "*какой-то комментарий*"

## Ветки. 

__*Ветка*__ — это указатель какого-то коммита. Так как коммит знает, какой коммит был до него, когда ветка указывает на какой-то коммит, к ней относятся и все те предыдущие. 

Исходя из этого можно сказать, что веток, указывающих на один и тот же коммит, может быть сколько угодно много.

Работа происходит в ветках, поэтому когда создается новый коммит, ветка переносит свой указатель на более новый коммит.

![схема веток](ветки.jpg)

## Как добавить изображение в Git.

